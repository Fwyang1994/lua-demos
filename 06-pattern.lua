
-- 不支持正则表达式， 但是可以通过 string 库的 gsub 和 gmatch 两个函数，实现绝大部分的功能

s = "hello world"

-- 返回子串，在目标字符串中存在的起止坐标
starts, ends = string.find(s, "hello")
print(starts, ends)
print(string.sub(s, starts, ends))

-- 直接返回匹配到的字串
print(string.match(s, "hello"))
dates = "today is 2023-07-10"
-- 高级匹配用法
print(string.match(dates, "%d+-%d+-%d+"))

--[[
函数string.gsub有3个必选参数：目标字符串、模式和替换字符串（replacementstring），
其基本用法是将目标字符串中所有出现模式的地方换成替换字符串：
返回2个个结果，1，替换后的字符串  2，发生替换的次数。
]]
print(string.gsub(s, "world", "lua"))

-- 函数string.gmatch返回一个函数，通过返回的函数可以遍历一个字符串中所有出现的指定模式。
-- 应该是返回一个迭代器，类似 ipairs
words = {}
for w in string.gmatch(s, "%a+") do
    words[#words + 1] = w
end

for i, v in ipairs(words) do
    print(i, v)
end

--[[
对于Lua语言的解析器而言，模式仅仅是普通的字符串。
模式与其他的字符串一样遵循相同的规则，并不会被特殊对待；
只有模式匹配相关的函数才会把它们当作模式进行解析。
由于反斜杠是Lua语言中的转义符，所以我们应该避免将它传递给任何函数。
模式本身就难以阅读，到处把"\"换成"\\"就更加火上浇油了。
]]

--[[
Lua语言中的模式使用百分号（percent sign）作为转义符（C语言中的一些函数采用的也是同样的方式，如函数printf和函数strftime）。
总体上，所有被转义的字母都具有某些特殊含义（例如'%a'匹配所有字母），而所有被转义的非字母则代表其本身（例如'%.'匹配一个点）。
当在模式中使用时，还有一些被称为魔法字符（ magic character ）的字符具有特殊含义。
Lua语言的模式所使用的魔法字符包括：() . % + - * ? [] ^ $
]]

--[==[
可以使用字符集（ char-set ）来创建自定义的字符分类，只需要在方括号
内将单个字符和字符分类组合起来即可。例如，字符集'[%w_]'匹配所有以下画
线结尾的字母和数字，'[01]'匹配二进制数字，'[%[%]]'匹配方括号。
如果想要统计一段文本中元音的数量，可以使用如下的代码：
]==]
text = s
-- gsub 返回替换后的字符串 和 替换次数， 这里只取次数
_, nvow = string.gsub(text, "[AEIOUaeiou]", "")
print(nvow)

--[[
还可以在字符集中包含一段字符范围，做法是写出字符范围的第一个字符和最后一个字符并用横线将它们连接在一起。
由于大多数常用的字符范围都被预先定义了，所以这个功能很少被使用。
例如，'%d'相当于'[0-9]'，'%x'相当于'[0-9a-fA-F]'。
不过，如果需要查找一个八进制的数字，那么使用'[0-7]'就比显式地枚举'[01234567]'强多了。
]]
-- 这个字符范围看起来和正则表达式是一致的，不支持正则实在是个败笔

--[[
在字符集前加一个补字符^就可以得到这个字符集对应的补集：
模式'[^0-7]'代表所有八进制数字以外的字符，
模式'[^\n]'则代表除换行符以外的其他字符。
尽管如此，我们还是要记得对于简单的分类来说可以使用大写形式来获得对应的补集：'%S'显然要比'[^%s]'更简单。
]]

--[[
还可以通过描述模式中重复和可选部分的修饰符（modifier，在其他语言中也被译为限定符）来让模式更加有用。
Lua语言中的模式提供了4种修饰符：
+ 重复1次或多次
* 重复0次或多次
- 重复0次或多次（最小匹配）
? 可选（出现0次或1次）
]]

-- 下面字符串是一段c代码，使用 lua 匹配去除所有的注释
test = "int x; /* x */ int y; /* y */"
-- 使用最小匹配的方式，可以匹配多次，替换多次
print(string.gsub(test, "/%*.*%*/", ""))
print(string.gsub(test, "/%*.-%*/", ""))

--[[
^和$字符只有位于模式的开头和结尾时才具有特殊含义；否则，它们仅仅就是与其自身相匹配的普通字符。
这里当这两个字符位于模式的开头和结尾时，与正则表达式用法一致
]]

--[[
模式'%b'匹配成对的字符串，它的写法是'%b xy '，
其中 x 和 y 是任意两个不同的字符， x 作为起始字符而 y 作为结束字符。
例如，模式'%b（）'匹配以左括号开始并以对应右括号结束的子串：
通常，我们使用'%b（）'、'%b[]'、'%b{}'或'%b<>'等作为模式，但实际上可以用任意不同的字符作为分隔符。
]]
s = "hello (lua) world"
print(string.gsub(s, "%b()", ""))

