
-- 不支持正则表达式， 但是可以通过 string 库的 gsub 和 gmatch 两个函数，实现绝大部分的功能

s = "hello world"

-- 返回子串，在目标字符串中存在的起止坐标
starts, ends = string.find(s, "hello")
print(starts, ends)
print(string.sub(s, starts, ends))

-- 直接返回匹配到的字串
print(string.match(s, "hello"))
dates = "today is 2023-07-10"
-- 高级匹配用法
print(string.match(dates, "%d+-%d+-%d+"))

--[[
函数string.gsub有3个必选参数：目标字符串、模式和替换字符串（replacementstring），
其基本用法是将目标字符串中所有出现模式的地方换成替换字符串：
返回2个个结果，1，替换后的字符串  2，发生替换的次数。
]]
print(string.gsub(s, "world", "lua"))

-- 函数string.gmatch返回一个函数，通过返回的函数可以遍历一个字符串中所有出现的指定模式。
-- 应该是返回一个迭代器，类似 ipairs
words = {}
for w in string.gmatch(s, "%a+") do
    words[#words + 1] = w
end

for i, v in ipairs(words) do
    print(i, v)
end

--[[
对于Lua语言的解析器而言，模式仅仅是普通的字符串。
模式与其他的字符串一样遵循相同的规则，并不会被特殊对待；
只有模式匹配相关的函数才会把它们当作模式进行解析。
由于反斜杠是Lua语言中的转义符，所以我们应该避免将它传递给任何函数。
模式本身就难以阅读，到处把"\"换成"\\"就更加火上浇油了。
]]

--[[
Lua语言中的模式使用百分号（percent sign）作为转义符（C语言中的一些函数采用的也是同样的方式，如函数printf和函数strftime）。
总体上，所有被转义的字母都具有某些特殊含义（例如'%a'匹配所有字母），而所有被转义的非字母则代表其本身（例如'%.'匹配一个点）。
当在模式中使用时，还有一些被称为魔法字符（ magic character ）的字符具有特殊含义。
Lua语言的模式所使用的魔法字符包括：() . % + - * ? [] ^ $
]]

--[==[
可以使用字符集（ char-set ）来创建自定义的字符分类，只需要在方括号
内将单个字符和字符分类组合起来即可。例如，字符集'[%w_]'匹配所有以下画
线结尾的字母和数字，'[01]'匹配二进制数字，'[%[%]]'匹配方括号。
如果想要统计一段文本中元音的数量，可以使用如下的代码：
]==]
text = s
-- gsub 返回替换后的字符串 和 替换次数， 这里只取次数
_, nvow = string.gsub(text, "[AEIOUaeiou]", "")
print(nvow)

--[[
还可以在字符集中包含一段字符范围，做法是写出字符范围的第一个字符和最后一个字符并用横线将它们连接在一起。
由于大多数常用的字符范围都被预先定义了，所以这个功能很少被使用。
例如，'%d'相当于'[0-9]'，'%x'相当于'[0-9a-fA-F]'。
不过，如果需要查找一个八进制的数字，那么使用'[0-7]'就比显式地枚举'[01234567]'强多了。
]]
-- 这个字符范围看起来和正则表达式是一致的，不支持正则实在是个败笔

--[[
在字符集前加一个补字符^就可以得到这个字符集对应的补集：
模式'[^0-7]'代表所有八进制数字以外的字符，
模式'[^\n]'则代表除换行符以外的其他字符。
尽管如此，我们还是要记得对于简单的分类来说可以使用大写形式来获得对应的补集：'%S'显然要比'[^%s]'更简单。
]]

--[[
还可以通过描述模式中重复和可选部分的修饰符（modifier，在其他语言中也被译为限定符）来让模式更加有用。
Lua语言中的模式提供了4种修饰符：
+ 重复1次或多次
* 重复0次或多次
- 重复0次或多次（最小匹配）
? 可选（出现0次或1次）
]]

-- 下面字符串是一段c代码，使用 lua 匹配去除所有的注释
test = "int x; /* x */ int y; /* y */"
-- 使用最小匹配的方式，可以匹配多次，替换多次
print(string.gsub(test, "/%*.*%*/", ""))
print(string.gsub(test, "/%*.-%*/", ""))

--[[
^和$字符只有位于模式的开头和结尾时才具有特殊含义；否则，它们仅仅就是与其自身相匹配的普通字符。
这里当这两个字符位于模式的开头和结尾时，与正则表达式用法一致
]]

--[[
模式'%b'匹配成对的字符串，它的写法是'%b xy '，
其中 x 和 y 是任意两个不同的字符， x 作为起始字符而 y 作为结束字符。
例如，模式'%b（）'匹配以左括号开始并以对应右括号结束的子串：
通常，我们使用'%b（）'、'%b[]'、'%b{}'或'%b<>'等作为模式，但实际上可以用任意不同的字符作为分隔符。
]]
s = "hello (lua) world"
print(string.gsub(s, "%b()", ""))

--[[
模式'%f[ char-set ]'代表前置模式（ frontier pattern ）。
该模式只有在后一个字符位于 char-set 内而前一个字符不在时匹配一个空字符串
模式'%f[%w]'匹配位于一个非字母或数字的字符和一个字母或数字的字符之间的前置，
而模式'%f[%W]'则匹配一个字母或数字的字符和一个非字母或数字的字符之间的前置。
]]

s1 = "the hello the world"
print(string.gsub(s1, "%f[%w]the%f[%W]", "crazy"))
--[[
前置模式把目标字符串中第一个字符前和最后一个字符后的位置当成空字符（ASCII编码的\0）。
在前例中，第一个"the"在不属于集合'[%w]'的空字符和属于集合'[%w]'的t之间匹配了一个前置。
]]
-- 看起来一点卵用都没有，不管这个


-- capture 捕获机制
--[[
捕获（ capture ）机制允许根据一个模式从目标字符串中抽出与该模式匹配的内容来用于后续用途，
可以通过把模式中需要捕获的部分放到一对圆括号内来指定捕获。
模式'%a+'表示一个非空的字母序列，模式'%s*'表示一个可能为空的空白序列。
因此，上例中的这个模式表示一个字母序列、紧跟着空白序列、一个等号、空白序列以及另一个字母序列。
模式中的两个字母序列被分别放在圆括号中，因此在匹配时就能捕获到它们。
]]
p = "name = anna";
key, val = string.match(p, "(%a+)%s*=%s*(%a+)")
print(key, val)

-- 在这个示例中，使用了3个捕获，每个捕获对应一个数字序列。
dates = "today is 2023-07-10"
y, m, d = string.match(dates, "(%d+)-(%d+)-(%d+)")
print( y, m, d )

