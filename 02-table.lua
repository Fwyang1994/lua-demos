
--[[
Lua语言中的表本质上是一种辅助数组（associative array），这种数组不
仅可以使用数值作为索引，也可以使用字符串或其他任意类型的值作为索引
（nil除外）。
]]

-- 创建表
a = {}
x = "x"
a[x] = 10
a[20] = "hello"
print( a[x], a[10], a[20], a["x"] )

-- 表永远是匿名的，表本身和保存表的变量之间没有固定的关系：
b = a
print( b[x], b[10], b[20], b["x"] )
-- 表是独立存在的，任何变量都只能保存表的引用，而不是表本身
b[x] = 30
print( a[x], b[x] )

-- 对于一个表而言，当程序中不再有指向它的引用时，垃圾收集器会最终删除这个表并重用其占用的内存。
-- 把 a b 都重新赋值为 nil， 程序中不再有指向它的引用， GC就会自动回收
--a = nil
--b = nil

-- 把表中的元素赋值给一个变量时，是值传递，并不是 表中元素的引用
c = b[20]
print( b[20], c )
b[20] = "haha"
print( b[20], c )

-- 如同全局变量一样，未经初始化的表元素为nil，将nil赋值给表元素可以将其删除。

-- 可以把表当做结构体进行调用和赋值，增加代码的可读性
a.hello = "hello world"
print( a["hello"], a.x )

-- 当索引是数字时， 可以使用显示类型转换，以明确索引的类型
-- 因为 b["20"] , b[20] 在作为索引时， 是不同的两个值
print( b["20"] , b[20] )

-- 构造器第一个元素的索引是1而不是0
str = {"a", "b"}
print( str[0], str[1], str[2] )  -- nil	a	b
-- Lua语言还提供了一种初始化记录式（record-like）表的特殊语法：
a1 = { x=10, y=20}
print( a1.x, a1.y ) -- 10	20
-- 可以使用另一种更加通用的构造器，即通过方括号括起来的表达式显式地指定每一个索引：
a2 = { [0]="a", [1]="b", [2]="c" }
-- 无论使用哪种方式创建表，都可以随时增加或删除表元素：

-- 如果想表示常见的数组（array）或列表（list），那么只需要使用整型作为索引的表即可: (必须从1开始)
-- 此时可以使用， 获取长度的操作符 # 来获取 数组 或 列表的长度
print( #a2 )

--[[
当向一个列表中写入了10行数据后，由于该
列表的数值类型的索引为1,2,...,10，所以可以很容易地知道列表的长度就是
10。这种技巧只有在列表中不存在空洞（ hole ）时（即所有元素均不为nil）
才有效，此时我们把这种所有元素都不为nil的数组称为序列（ sequence ）
]]

-- 遍历表， 我们可以使用pairs迭代器遍历表中的键值对：
--[[
受限于表在Lua语言中的底层实现机制，遍历过程中元素的出现顺序可能
是随机的，相同的程序在每次运行时也可能产生不同的顺序。唯一可以确定的
是，在遍历的过程中每个元素会且只会出现一次。
]]
t = { "a", "b", 22 }
t.x = 15
for i, v in pairs(t) do
    print( i, v )
end

-- 模拟表的安全访问操作符
--[[
对于表达式a or {}，当a为nil时其结果是一个空表。因此，对于表达式（a
or{}）.b，当a为nil时其结果也同样是nil。
]]
-- 标准库底层也是使用表 来实现的
print( (string or {} ).len(a.hello) )


print("###########################")
-- 表标准库提供了操作列表和序列的一些常用函数
-- 函数table.insert向序列的指定位置插入一个元素，其他元素依次后移。

t = { "a", "b", 22 }
table.insert(t, 1, "a1")
print( t[1], t[2], t[3], t[4] )

-- 函数table.remove删除并返回序列指定位置的元素，然后将其后的元素向前移动填充删除元素后造成的空洞。
table.remove(t, 2)
print( t[1], t[2], t[3], t[4] )

--[[
5.3对于移动表中的元素引入了一个更通用的函数
table.move（a,f,e,t），调用该函数可以将表a中从索引f到e的元素（包含索引
f和索引e对应的元素本身）移动到位置t上。例如，如下代码可以在列表a的开
头插入一个元素：
]]
a = {1,2,3,4,5}
table.move(a, 1, #a, 2)
a[1] = 0

-- 如下代码可以在列表a的开头删除一个元素：
--[[
应该注意，在计算机领域，移动（ move ）实际上是将一个值从一个地方
拷贝（ copy ）到另一个地方。因此，像上面的例子一样，我们必须在移动后显式地把最后一个元素删除。
]]
table.move(a, 2, #a, 1)
a[#a] = nil
--for i, v in ipairs(a) do
--    print(i, v)
--end
-- 使用move，可以范围性的批量移动列表中的元素，兴许可以减少开销

-- table.move（a,1,#a,1,{}）返回列表a的一个克隆（clone）（通过将列表a中的所有元素拷贝到新列表中）
b = table.move(a,1,#a,1,{})
-- table.move（a,1,#a,#b+1,b）将列表a中的所有元素复制到列表b的末尾。
table.move(a, 1, #a, #b+1, b)
--for i, v in ipairs(b) do
--    print(i, v)
--end


